# Задание 3. Переход на Event-Driven архитектуру

#### Проблемы существующей системы

#### Зависимость от синхронных REST-запросов

Проблемы в сервисе ins-product-aggregator - сейчас он при каждом запросе "обходит" все страховые компании. При увеличении количества компаний (5 текущих + 5 новых) время обработки может существенно вырасти.
При этом, если у одной из компаний задержки или сбои, этот синхронный вызов "подвешивает" ответ для всех запросов.

Сервис core-app опрашивает ins-product-aggregator раз в 15 минут, а ins-comp-settlement — раз в сутки (ночью). Это означает, что данные о продуктах и тарифах могут быть неактуальными вплоть до 15 минут (или суток) и приводить к ошибкам при оформлении новых страховок.

При большом числе синхронных запросов (особенно при увеличении компаний), проблемы ins-product-aggregator могут стать критичными. Необходимо будет либо сильно масштабировать ins-product-aggregator, либо рисковать SLA.

Ins-comp-settlement зависит от core-app - раз в сутки делает большой REST-запрос к нему (получает список оформленных за день страховок). При сбое или задержке в core-app формирование реестров откладывается.

В целом, синхронные REST-вызовы неустойчивы к ошибкам, сетевым сбоям и высоким задержкам. Если один сервис недоступен, цепочка "рушится".

#### Потенциальные риски при росте количества партнёров

Если данные о продуктах и тарифах будут ещё больше расти, то "собирать всё одним куском" и кэшировать локально станет сложно и рискованно (старая информация).

Таким образом, мы видим, что основная проблема - это синхронная схема взаимодействия с внешними API, которая ведёт к задержкам, увеличению ошибок и необходимостью серьёзной балансировки, кэширования, ретраев.
А запоздалое обновление (15 минут / сутки) создаёт риск работы с неактуальными тарифами и продуктами.

#### Предложения по переходу на Event-Driven архитектуру

Решение видится в использовании ins-product-aggregator'а как источника событий (publisher). Вместо того чтобы при каждом запросе к ins-product-aggregator тот синхронно вызывал все страховые компании, он может поддерживать актуальные тарифы у себя в хранилище (кэше), обновляя их асинхронно.
При появлении или изменении тарифа у страховой компании (или с некоторой периодичностью) ins-product-aggregator публикует событие о новых тарифах в Event Streaming платформу (Kafka или RabbitMQ).
Сore-app и ins-comp-settlement как подписчики (subscribers)

Вместо периодических REST-запросов, оба сервиса подписываются на топики (например, "Тарифы обновлены" и "Список страховых продуктов обновлён").
При получении нужных событий они локально обновляют свои реплики данных — почти сразу, а не через 15 минут / сутки.

Когда в core-app оформляется новая страховка, сервис мог бы записать транзакцию в свою БД + в outbox-таблицу, и затем (через механизм транзакционного прокси) публиковать событие: "Заявка оформлена".
Ins-comp-settlement и другие сервисы получают событие "Заявка оформлена" и обновляют свою базу. Тогда нет необходимости в больших ночных REST-запросах для получения реестра за сутки — по сути, ins-comp-settlement всегда знает актуальное состояние.
При этом возможность собрать большой реестр остается - если это требуется для какой-либо верификации данных.

Асинхронная передача уменьшает критические пути (нет долгих REST-вызовов). Если сервис временно недоступен, события накапливаются в очереди. Сервис подтянет их, как только будет в строю.
При добавлении ещё 5 страховых компаний ins-product-aggregator будет обновляться асинхронно, не блокируя поток синхронных запросов.

[Ссылка на диаграмму](https://drive.google.com/file/d/1uccpMNYWOUjbiNWZYIF2F9CIzsAAYjvl/view?usp=sharing)